{
  "address": "0x381EBA262eb91f55ca44748B1151406F5Da5bd09",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_endpoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AddressInsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedInnerCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDelegate",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEndpointCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LzTokenUnavailable",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "NoPeer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "msgValue",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughNative",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "OnlyEndpoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "sender",
          "type": "bytes32"
        }
      ],
      "name": "OnlyPeer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "chainId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "blockHash",
          "type": "bytes32"
        }
      ],
      "name": "BlockHashReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "name": "PeerSet",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_blockNumber",
          "type": "uint64"
        },
        {
          "internalType": "bytes32",
          "name": "_blockhash",
          "type": "bytes32"
        }
      ],
      "name": "addToHistory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "origin",
          "type": "tuple"
        }
      ],
      "name": "allowInitializePath",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endpoint",
      "outputs": [
        {
          "internalType": "contract ILayerZeroEndpointV2",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_blockNumber",
          "type": "uint64"
        }
      ],
      "name": "getBlockHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        }
      ],
      "name": "getBlockHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_blockNumber",
          "type": "uint64"
        }
      ],
      "name": "isBlockInHistory",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        }
      ],
      "name": "isComposeMsgSender",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "_origin",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_guid",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_executor",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "lzReceive",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "nextNonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "nonce",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oAppVersion",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "senderVersion",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "receiverVersion",
          "type": "uint64"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "peers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "_payInLzToken",
          "type": "bool"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "nativeFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lzTokenFee",
              "type": "uint256"
            }
          ],
          "internalType": "struct MessagingFee",
          "name": "fee",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        }
      ],
      "name": "send",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "guid",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "nativeFee",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lzTokenFee",
                  "type": "uint256"
                }
              ],
              "internalType": "struct MessagingFee",
              "name": "fee",
              "type": "tuple"
            }
          ],
          "internalType": "struct MessagingReceipt",
          "name": "receipt",
          "type": "tuple"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_delegate",
          "type": "address"
        }
      ],
      "name": "setDelegate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_peer",
          "type": "bytes32"
        }
      ],
      "name": "setPeer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "chainId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "timestamp",
          "type": "uint64"
        }
      ],
      "name": "visions",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "blockhash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x68a5e3b0e5490acec92aa3cba3dd8b32cc29e443f20713aad730b627eccf1ce1",
  "receipt": {
    "to": null,
    "from": "0x13E5E5deA5620A8f4B5C430339795cb5BaB6676e",
    "contractAddress": "0x381EBA262eb91f55ca44748B1151406F5Da5bd09",
    "transactionIndex": 1,
    "gasUsed": "1488785",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000200000000000800001000002000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000020000020000000200000000000810000000000000000000000000000000400000000000000020000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000010000000000000000000000000000",
    "blockHash": "0x510bf018b473a7c61741437e20c36d88b7cdf72c0e708555400ec8ea62189382",
    "transactionHash": "0x68a5e3b0e5490acec92aa3cba3dd8b32cc29e443f20713aad730b627eccf1ce1",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 63671246,
        "transactionHash": "0x68a5e3b0e5490acec92aa3cba3dd8b32cc29e443f20713aad730b627eccf1ce1",
        "address": "0x381EBA262eb91f55ca44748B1151406F5Da5bd09",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000013e5e5dea5620a8f4b5c430339795cb5bab6676e"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x510bf018b473a7c61741437e20c36d88b7cdf72c0e708555400ec8ea62189382"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 63671246,
        "transactionHash": "0x68a5e3b0e5490acec92aa3cba3dd8b32cc29e443f20713aad730b627eccf1ce1",
        "address": "0x6EDCE65403992e310A62460808c4b910D972f10f",
        "topics": [
          "0x6ee10e9ed4d6ce9742703a498707862f4b00f1396a87195eb93267b3d7983981"
        ],
        "data": "0x000000000000000000000000381eba262eb91f55ca44748b1151406f5da5bd0900000000000000000000000013e5e5dea5620a8f4b5c430339795cb5bab6676e",
        "logIndex": 1,
        "blockHash": "0x510bf018b473a7c61741437e20c36d88b7cdf72c0e708555400ec8ea62189382"
      }
    ],
    "blockNumber": 63671246,
    "cumulativeGasUsed": "1488785",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x13E5E5deA5620A8f4B5C430339795cb5BaB6676e",
    "0x6EDCE65403992e310A62460808c4b910D972f10f"
  ],
  "numDeployments": 1,
  "solcInputHash": "6666b513a922b1a7869c34c682a38136",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzTokenUnavailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"NoPeer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"msgValue\",\"type\":\"uint256\"}],\"name\":\"NotEnoughNative\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnlyEndpoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"OnlyPeer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"BlockHashReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"name\":\"PeerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_blockhash\",\"type\":\"bytes32\"}],\"name\":\"addToHistory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"origin\",\"type\":\"tuple\"}],\"name\":\"allowInitializePath\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpointV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_blockNumber\",\"type\":\"uint64\"}],\"name\":\"getBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_blockNumber\",\"type\":\"uint64\"}],\"name\":\"isBlockInHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"isComposeMsgSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"_origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oAppVersion\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"senderVersion\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"receiverVersion\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"peers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_payInLzToken\",\"type\":\"bool\"}],\"name\":\"quote\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct MessagingFee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"guid\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"internalType\":\"struct MessagingFee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"internalType\":\"struct MessagingReceipt\",\"name\":\"receipt\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_peer\",\"type\":\"bytes32\"}],\"name\":\"setPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"visions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockhash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{\"allowInitializePath((uint32,bytes32,uint64))\":{\"details\":\"This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.This defaults to assuming if a peer has been set, its initialized. Can be overridden by the OApp if there is other logic to determine this.\",\"params\":{\"origin\":\"The origin information containing the source endpoint and sender address.\"},\"returns\":{\"_0\":\"Whether the path has been initialized.\"}},\"isComposeMsgSender((uint32,bytes32,uint64),bytes,address)\":{\"details\":\"_origin The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message._message The lzReceive payload.Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.The default sender IS the OAppReceiver implementer.\",\"params\":{\"_sender\":\"The sender address.\"},\"returns\":{\"_0\":\"isSender Is a valid sender.\"}},\"lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)\":{\"details\":\"Entry point for receiving messages or packets from the endpoint.Entry point for receiving msg/packet from the LayerZero endpoint.\",\"params\":{\"_executor\":\"The address of the executor for the received message.\",\"_extraData\":\"Additional arbitrary data provided by the corresponding executor.\",\"_guid\":\"The unique identifier for the received LayerZero message.\",\"_message\":\"The payload of the received message.\",\"_origin\":\"The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message.\"}},\"nextNonce(uint32,bytes32)\":{\"details\":\"_srcEid The source endpoint ID._sender The sender address.The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.Is required by the off-chain executor to determine the OApp expects msg execution is ordered.This is also enforced by the OApp.By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\",\"returns\":{\"nonce\":\"The next nonce.\"}},\"oAppVersion()\":{\"returns\":{\"receiverVersion\":\"The version of the OAppReceiver.sol implementation.\",\"senderVersion\":\"The version of the OAppSender.sol implementation.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setDelegate(address)\":{\"details\":\"Only the owner/admin of the OApp can call this function.Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\",\"params\":{\"_delegate\":\"The address of the delegate to be set.\"}},\"setPeer(uint32,bytes32)\":{\"details\":\"Only the owner/admin of the OApp can call this function.Indicates that the peer is trusted to send LayerZero messages to this OApp.Set this to bytes32(0) to remove the peer address.Peer is a bytes32 to accommodate non-evm chains.\",\"params\":{\"_eid\":\"The endpoint ID.\",\"_peer\":\"The address of the peer to be associated with the corresponding endpoint.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allowInitializePath((uint32,bytes32,uint64))\":{\"notice\":\"Checks if the path initialization is allowed based on the provided origin.\"},\"endpoint()\":{\"notice\":\"Retrieves the LayerZero endpoint associated with the OApp.\"},\"isComposeMsgSender((uint32,bytes32,uint64),bytes,address)\":{\"notice\":\"Indicates whether an address is an approved composeMsg sender to the Endpoint.\"},\"nextNonce(uint32,bytes32)\":{\"notice\":\"Retrieves the next nonce for a given source endpoint and sender address.\"},\"oAppVersion()\":{\"notice\":\"Retrieves the OApp version information.\"},\"peers(uint32)\":{\"notice\":\"Retrieves the peer (OApp) associated with a corresponding endpoint.\"},\"setDelegate(address)\":{\"notice\":\"Sets the delegate address for the OApp.\"},\"setPeer(uint32,bytes32)\":{\"notice\":\"Sets the peer address (OApp instance) for a corresponding endpoint.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Lisan.sol\":\"Lisan\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\\n// solhint-disable-next-line no-unused-import\\nimport { OAppSender, MessagingFee, MessagingReceipt } from \\\"./OAppSender.sol\\\";\\n// @dev Import the 'Origin' so it's exposed to OApp implementers\\n// solhint-disable-next-line no-unused-import\\nimport { OAppReceiver, Origin } from \\\"./OAppReceiver.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OApp\\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\\n */\\nabstract contract OApp is OAppSender, OAppReceiver {\\n    /**\\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\\n     */\\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol implementation.\\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\\n     */\\n    function oAppVersion()\\n        public\\n        pure\\n        virtual\\n        override(OAppSender, OAppReceiver)\\n        returns (uint64 senderVersion, uint64 receiverVersion)\\n    {\\n        return (SENDER_VERSION, RECEIVER_VERSION);\\n    }\\n}\\n\",\"keccak256\":\"0xac362c4c291fad2f1511a968424b2e78a5ad502d1c867bd31da04be742aca8c5\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IOAppCore, ILayerZeroEndpointV2 } from \\\"./interfaces/IOAppCore.sol\\\";\\n\\n/**\\n * @title OAppCore\\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\\n */\\nabstract contract OAppCore is IOAppCore, Ownable {\\n    // The LayerZero endpoint associated with the given OApp\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n\\n    // Mapping to store peers associated with corresponding endpoints\\n    mapping(uint32 eid => bytes32 peer) public peers;\\n\\n    /**\\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\\n     *\\n     * @dev The delegate typically should be set as the owner of the contract.\\n     */\\n    constructor(address _endpoint, address _delegate) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n\\n        if (_delegate == address(0)) revert InvalidDelegate();\\n        endpoint.setDelegate(_delegate);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\\n        _setPeer(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\\n        peers[_eid] = _peer;\\n        emit PeerSet(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\\n     * ie. the peer is set to bytes32(0).\\n     * @param _eid The endpoint ID.\\n     * @return peer The address of the peer associated with the specified endpoint.\\n     */\\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\\n        bytes32 peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeer(_eid);\\n        return peer;\\n    }\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp.\\n     * @param _delegate The address of the delegate to be set.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\\n     */\\n    function setDelegate(address _delegate) public onlyOwner {\\n        endpoint.setDelegate(_delegate);\\n    }\\n}\\n\",\"keccak256\":\"0x13a9c2d1d2c1f086b8624f2e84c4a4702212daae36f701d92bb915b535cbe4cc\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IOAppReceiver, Origin } from \\\"./interfaces/IOAppReceiver.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OAppReceiver\\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\\n */\\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\\n    // Custom error message for when the caller is not the registered endpoint/\\n    error OnlyEndpoint(address addr);\\n\\n    // @dev The version of the OAppReceiver implementation.\\n    // @dev Version is bumped when changes are made to this contract.\\n    uint64 internal constant RECEIVER_VERSION = 2;\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     *\\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\\n     * ie. this is a RECEIVE only OApp.\\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\\n     */\\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\\n        return (0, RECEIVER_VERSION);\\n    }\\n\\n    /**\\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\\n     * @dev _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @dev _message The lzReceive payload.\\n     * @param _sender The sender address.\\n     * @return isSender Is a valid sender.\\n     *\\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\\n     * @dev The default sender IS the OAppReceiver implementer.\\n     */\\n    function isComposeMsgSender(\\n        Origin calldata /*_origin*/,\\n        bytes calldata /*_message*/,\\n        address _sender\\n    ) public view virtual returns (bool) {\\n        return _sender == address(this);\\n    }\\n\\n    /**\\n     * @notice Checks if the path initialization is allowed based on the provided origin.\\n     * @param origin The origin information containing the source endpoint and sender address.\\n     * @return Whether the path has been initialized.\\n     *\\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\\n     * @dev This defaults to assuming if a peer has been set, its initialized.\\n     * Can be overridden by the OApp if there is other logic to determine this.\\n     */\\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\\n        return peers[origin.srcEid] == origin.sender;\\n    }\\n\\n    /**\\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\\n     * @dev _srcEid The source endpoint ID.\\n     * @dev _sender The sender address.\\n     * @return nonce The next nonce.\\n     *\\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\\n     * @dev This is also enforced by the OApp.\\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\\n     */\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Entry point for receiving messages or packets from the endpoint.\\n     * @param _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @param _guid The unique identifier for the received LayerZero message.\\n     * @param _message The payload of the received message.\\n     * @param _executor The address of the executor for the received message.\\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\\n     *\\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\\n     */\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\\n\\n        // Ensure that the sender matches the expected peer for the source endpoint.\\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\\n\\n        // Call the internal OApp implementation of lzReceive.\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /**\\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\\n     */\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x0174e9f1ec4cefe4b5adc26c392269c699b9ff75965364e5b7264426a462c70b\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OAppSender\\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\\n */\\nabstract contract OAppSender is OAppCore {\\n    using SafeERC20 for IERC20;\\n\\n    // Custom error messages\\n    error NotEnoughNative(uint256 msgValue);\\n    error LzTokenUnavailable();\\n\\n    // @dev The version of the OAppSender implementation.\\n    // @dev Version is bumped when changes are made to this contract.\\n    uint64 internal constant SENDER_VERSION = 1;\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     *\\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\\n     * ie. this is a SEND only OApp.\\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\\n     */\\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\\n        return (SENDER_VERSION, 0);\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\\n     * @return fee The calculated MessagingFee for the message.\\n     *      - nativeFee: The native fee for the message.\\n     *      - lzTokenFee: The LZ token fee for the message.\\n     */\\n    function _quote(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        bool _payInLzToken\\n    ) internal view virtual returns (MessagingFee memory fee) {\\n        return\\n            endpoint.quote(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\\n                address(this)\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _fee The calculated LayerZero fee for the message.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\\n     * @return receipt The receipt for the sent message.\\n     *      - guid: The unique identifier for the sent message.\\n     *      - nonce: The nonce of the sent message.\\n     *      - fee: The LayerZero fee incurred for the message.\\n     */\\n    function _lzSend(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        MessagingFee memory _fee,\\n        address _refundAddress\\n    ) internal virtual returns (MessagingReceipt memory receipt) {\\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\\n        uint256 messageValue = _payNative(_fee.nativeFee);\\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\\n\\n        return\\n            // solhint-disable-next-line check-send-result\\n            endpoint.send{ value: messageValue }(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\\n                _refundAddress\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the native fee associated with the message.\\n     * @param _nativeFee The native fee to be paid.\\n     * @return nativeFee The amount of native currency paid.\\n     *\\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\\n     * this will need to be overridden because msg.value would contain multiple lzFees.\\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\\n     */\\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\\n        return _nativeFee;\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the LZ token fee associated with the message.\\n     * @param _lzTokenFee The LZ token fee to be paid.\\n     *\\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\\n     */\\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\\n        address lzToken = endpoint.lzToken();\\n        if (lzToken == address(0)) revert LzTokenUnavailable();\\n\\n        // Pay LZ token fee by sending tokens to the endpoint.\\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\\n    }\\n}\\n\",\"keccak256\":\"0x518cf4adca601923ed4baa6619846a253ea32b8d8775f8bc1faa3dfac7f67c20\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { ILayerZeroEndpointV2 } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\n\\n/**\\n * @title IOAppCore\\n */\\ninterface IOAppCore {\\n    // Custom error messages\\n    error OnlyPeer(uint32 eid, bytes32 sender);\\n    error NoPeer(uint32 eid);\\n    error InvalidEndpointCall();\\n    error InvalidDelegate();\\n\\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\\n    event PeerSet(uint32 eid, bytes32 peer);\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     */\\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\\n\\n    /**\\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\\n     * @return iEndpoint The LayerZero endpoint as an interface.\\n     */\\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\\n\\n    /**\\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\\n     */\\n    function peers(uint32 _eid) external view returns (bytes32 peer);\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) external;\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp Core.\\n     * @param _delegate The address of the delegate to be set.\\n     */\\n    function setDelegate(address _delegate) external;\\n}\\n\",\"keccak256\":\"0x40e49f2de74506e1da5dcaed53a39853f691647f4ceb0fccc8f49a68d3f47c58\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { ILayerZeroReceiver, Origin } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\n\\ninterface IOAppReceiver is ILayerZeroReceiver {\\n    /**\\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\\n     * @param _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @param _message The lzReceive payload.\\n     * @param _sender The sender address.\\n     * @return isSender Is a valid sender.\\n     *\\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\\n     * @dev The default sender IS the OAppReceiver implementer.\\n     */\\n    function isComposeMsgSender(\\n        Origin calldata _origin,\\n        bytes calldata _message,\\n        address _sender\\n    ) external view returns (bool isSender);\\n}\\n\",\"keccak256\":\"0xd26135185e19b3732746d4a9e2923e896f28dec8664bab161faea2ee26fcdc3d\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IMessageLibManager } from \\\"./IMessageLibManager.sol\\\";\\nimport { IMessagingComposer } from \\\"./IMessagingComposer.sol\\\";\\nimport { IMessagingChannel } from \\\"./IMessagingChannel.sol\\\";\\nimport { IMessagingContext } from \\\"./IMessagingContext.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n    bool payInLzToken;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint256 nativeFee;\\n    uint256 lzTokenFee;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketDelivered(Origin origin, address receiver);\\n\\n    event LzReceiveAlert(\\n        address indexed receiver,\\n        address indexed executor,\\n        Origin origin,\\n        bytes32 guid,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    event LzTokenSet(address token);\\n\\n    event DelegateSet(address sender, address delegate);\\n\\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLzToken(address _lzToken) external;\\n\\n    function lzToken() external view returns (address);\\n\\n    function nativeToken() external view returns (address);\\n\\n    function setDelegate(address _delegate) external;\\n}\\n\",\"keccak256\":\"0xf7f941bee89ea6369950fe54e8ac476ae6478b958b20fc0e8a83e8ff1364eac3\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { Origin } from \\\"./ILayerZeroEndpointV2.sol\\\";\\n\\ninterface ILayerZeroReceiver {\\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\\n\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x9641abba8d53b08bb517d1b74801dd15ea7b84d77a6719085bd96c8ea94e3ca0\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 eid;\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint256 expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config);\\n}\\n\",\"keccak256\":\"0x919b37133adff4dc528e3061deb2789c3149971b530c61e556fb3d09ab315dfc\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message cannot be verified for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n}\\n\",\"keccak256\":\"0x0878f64dffebf58c4165569416372f40860fab546b88cd926eba0d5cb6d8d972\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\\n    event LzComposeAlert(\\n        address indexed from,\\n        address indexed to,\\n        address indexed executor,\\n        bytes32 guid,\\n        uint16 index,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    function composeQueue(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index\\n    ) external view returns (bytes32 messageHash);\\n\\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x85bc7090134529ec474866dc4bb1c48692d518c756eb0a961c82574829c51901\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32 dstEid, address sender);\\n}\\n\",\"keccak256\":\"0xff0c546c2813dae3e440882f46b377375f7461b0714efd80bd3f0c6e5cb8da4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"../extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x37bb49513c49c87c4642a891b13b63571bc87013dde806617aa1efb54605f386\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/ILisan.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ninterface ILisan {\\n    function getBlockHash(\\n        uint64 _chainId,\\n        uint64 _blockNumber\\n    ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0x75ecbc0fe38a186916a2beac61da8b677b8e8c373d5a264cd498b6ca5d06ebc1\",\"license\":\"MIT\"},\"contracts/Lisan.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport \\\"./circuits/UltraVerifier.sol\\\";\\nimport \\\"./OChain.sol\\\";\\nimport \\\"./ILisan.sol\\\";\\n\\n// the lisan al gaib will point the way\\ncontract Lisan is ILisan, OChain {\\n    constructor(address _owner, address _endpoint) OChain(_endpoint, _owner) {}\\n\\n    function getBlockHash(\\n        uint64 _chainId,\\n        uint64 _blockNumber\\n    ) public view returns (bytes32) {\\n        return visions[_chainId][_blockNumber];\\n    }\\n\\n    function isBlockInHistory(\\n        uint64 _chainId,\\n        uint64 _blockNumber\\n    ) public view returns (bool) {\\n        return visions[_chainId][_blockNumber] != bytes32(0);\\n    }\\n\\n    // handy for testing - this functionality IRL needs to be only callable by OZ\\n    function addToHistory(\\n        uint64 _chainId,\\n        uint64 _blockNumber,\\n        bytes32 _blockhash\\n    ) public onlyOwner {\\n        visions[_chainId][_blockNumber] = _blockhash;\\n        emit BlockHashReceived(\\n            uint64(_chainId),\\n            uint64(_blockNumber),\\n            _blockhash\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xafcccca9e3ad15aa2f80cbbee08f998f8b64015041b7b8dc4aa62dbddc8431d6\",\"license\":\"MIT\"},\"contracts/OChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.22;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {OApp, MessagingFee, Origin} from \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\\\";\\nimport {MessagingReceipt} from \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\\\";\\n\\ncontract OChain is OApp {\\n    constructor(\\n        address _endpoint,\\n        address _delegate\\n    ) OApp(_endpoint, _delegate) Ownable(_delegate) {}\\n\\n    mapping(uint64 chainId => mapping(uint64 timestamp => bytes32 blockhash))\\n        public visions;\\n\\n    function getBlockHash(uint blockNumber) public view returns (bytes32) {\\n        require(\\n            block.number > blockNumber,\\n            \\\"Block number should be in the past\\\"\\n        );\\n        require(\\n            block.number - blockNumber <= 256,\\n            \\\"Block number is too far in the past\\\"\\n        );\\n\\n        return blockhash(blockNumber);\\n    }\\n\\n    function send(\\n        uint32 _dstEid,\\n        uint _blockNumber,\\n        bytes calldata _options\\n    ) external payable returns (MessagingReceipt memory receipt) {\\n        // get the block hash\\n        bytes32 hashToGet = getBlockHash(_blockNumber);\\n        require(hashToGet != 0, \\\"Blockhash not found\\\");\\n\\n        // encode the message\\n        bytes memory _payload = abi.encode(\\n            _blockNumber,\\n            hashToGet,\\n            block.chainid\\n        );\\n\\n        receipt = _lzSend(\\n            _dstEid,\\n            _payload,\\n            _options,\\n            MessagingFee(msg.value, 0),\\n            payable(msg.sender)\\n        );\\n    }\\n\\n    function quote(\\n        uint32 _dstEid,\\n        uint _blockNumber,\\n        bytes memory _options,\\n        bool _payInLzToken\\n    ) public view returns (MessagingFee memory fee) {\\n        bytes32 hashToGet = getBlockHash(_blockNumber);\\n        require(hashToGet != 0, \\\"Blockhash not found\\\");\\n\\n        bytes memory payload = abi.encode(_blockNumber, hashToGet);\\n\\n        fee = _quote(_dstEid, payload, _options, _payInLzToken);\\n    }\\n\\n    event BlockHashReceived(\\n        uint64 chainId,\\n        uint64 blockNumber,\\n        bytes32 blockHash\\n    );\\n\\n    function _lzReceive(\\n        Origin calldata /*_origin*/,\\n        bytes32 /*_guid*/,\\n        bytes calldata payload,\\n        address /*_executor*/,\\n        bytes calldata /*_extraData*/\\n    ) internal override {\\n        (uint blocknum, bytes32 blockHash, uint chainId) = abi.decode(\\n            payload,\\n            (uint, bytes32, uint)\\n        );\\n        visions[uint64(chainId)][uint64(blocknum)] = blockHash;\\n        emit BlockHashReceived(uint64(chainId), uint64(blocknum), blockHash);\\n    }\\n}\\n\",\"keccak256\":\"0x87e40d88065ef1528fba425d11dea8b55aafa6c36f0e1c1ae633de7bd7d2cc16\",\"license\":\"MIT\"},\"contracts/circuits/UltraVerifier.sol\":{\"content\":\"// Verification Key Hash: 8cde92c30971718b20b165fda566822e866c6618529cb9aea8ebc80449a91d32\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary UltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0x8cde92c30971718b20b165fda566822e866c6618529cb9aea8ebc80449a91d32;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000200000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x000000000000000000000000000000000000000000000000000000000000003a) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x1ded8980ae2bdd1a4222150e8598fc8c58f50577ca5a5ce3b2c87885fcd0b523) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30644cefbebe09202b4ef7f3ff53a4511d70ff06da772cc3785d6b74e0536081) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x240c1a685e64834fb0e94e06a8a0f333f9af6f9c5286ddfdd82c00f1fa70e4e7) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x2157acf2a6c6fed46256cbbc159b49d01f6f88ae94021c84080191977c9bc646) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x16b2d4fadc88e042e74c10181f6b74375531aa2af5c55465741bfd8a8bf8c6bc) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x0f2c4c34a81f79d1c1dcf3983f8afa61e9c45699faecfb50e2c3e7c1e061309a) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x11ab68307f04bae1f3c0e6b40ae0ac1b21ad33b8a4fb75efe52bd9bdaaadb6e7) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x241f2ce67192ad5a167b383d10c97eacdcbdac7e46eef156e33fae5de979427c) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x0efb022cc56002a6a657b23bdecfdfc2893c7fc6649336505f3dae6e8e87fbba) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x249f57afc65d98a9f02c25c684d06fd98f1c648e6c19b58c40f1f16e2bb23fae) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x2bb7dfae0c7c07b9f9ad33841449b560429c8920c29fe7935ca48cef157c1a3b) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x0ffc4ea5b74a0a5f44cd487d6118c54a790dd2c4e81cab07362be9dbc90c3683) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x2615b6d3ef9b52fdef4c960d2153ba92ef68acdb80d69c721b3043b8e160a1b7) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x26d97d19fa4abd5bf0f4411752b30f1d0d25ae8a5b4379496b749d8e42416aa1) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x15af2ebde446608834eed684b5a707f2f10d5b8e82f4d746c397213cdc663fed) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x20e4d8c13d11159b3d4ce6148cda81f6a50ef572cbb536c730b82b775306e6c6) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x0a410f851e75b83d0818578d196c18b030c191265e0536540e1111fb61fdf198) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x1ebe5df083408b3a5b5fe5b5e2c20407566af23e404b0098fbb1075a7ef4524c) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x2493c5fdf70b82a8c0c0d0368743f3122111c5188e8a1c026f25236883cf7386) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x13733a6308772d57f4b0a0dbc2cdc8ff9bfa89f0bf2456675d81269c4a6582e9) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x008d1c5934d38087d0415ebb1b135a279f0c3dd8b3024d449772d23eb8951b79) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x1d055115b6e350689abe06eab2998c2fbd326200411b4bdf60319d89629c320b) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x0b1566940013c37339aaf63dbad5096748637a397af8675f90a195276505ce74) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x13db32f13ffb81e9fb1acbc7799da454b5a5a35d8973b77c0808c9efccbcb34e) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x0ea64451ef3171b10ed3fcd5353af61582526cace68c3ad6af9b09368175e9d3) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x20ef95cb01a6b7001960649c4dd78cd39c42d88a8b1d5e00cbb0fe97389f0a6d) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x26c754b2f878f38311d75fcafc914e52177be8946ae3431262a7659b19276c4d) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x23c2eb452c08dffbf17211ac8dc33e57c68c081031c7b39b0b954646101b02b2) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x0f1a9af6f5ac6188c7fc7da1d1feeebadc365451b644a6345bdea2831c9dcabb) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x1cc8c2402c98688b2d206559f1dd3b995b57d94f69f97bced08dc64ba56332d4) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x0675730bf332f624f89107430b36ab262388281253597aa0f932a91138f2e702) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x014dd47ec9d0dbb83e8c874f43c5492b262f480db0aece16c3fb11376f0ec4b8) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x2c99f227cff84a996e5834fdf0c1eb9e1de4b7670e23fc3a616ebe71172f6da6) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x13d164616b38a57465b887ea67c8f29eb528beb1269331600442a1a5f85cdfc7) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x0134706007922c9cbe8f48d31ff21edbfede04034d6bfa228ee067e4c73a6480) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x2d411387c01f9cfda51a0bf9a79fd16f5650f9e6a00bdc4cd3c009a03a21a14f) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x2d5ee5ce9f4971de607ed3bc6955bdf571423171c9a4800562d8c1baefcb49f0) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x1d703d54ebc05484699f2d019fed1df51937d4dcfc257eb49f20dc560b639024) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x21b5151ea2da1676ff666c38605dba21dc1f1fa223bb259d4fd717e283690e9c) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x22e82ffb46740d8a3e7c2006a53f0f42bc65544d1084437c96a93804f88d0629) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x2636b9768731d24e2cbfb732a87f5639fa1214b1d8ed72758a7669e47621c249) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x1e5f96f4a6f549051d10f3a62628b6429d230b21daee643c118ad30f4c329d0b) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x1b005a3b228bca9a027edec23fca4403a8817571f3ed753cf5a2b6f6c6e0d3ac) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x279146395455b20d6db17db5da8008a49e473aa18c2f0f6fc4f172d40cfef2f2) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x144f6821f371783221dfa0d7877e2fa4cd62278fad734590bdd496f8fbac146f) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x159772bd8d5c6ed58ba5673ea5e17c7365e0306184b104a816b4abbdf0f6cd00) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x1c6fb5278c0a7694489c8afc305f9cba2580db19fa05fbd64f694bc70d7c74e2) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x2837dfc8c03572d2350a91e9c77d39263f75fefd9defdd71b41edee86f069d90) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x19c6dfb841091b14ab14ecc1145f527850fd246e940797d3f5fac783a376d0f0) // vk.work_root_inverse\\n        }\\n    }\\n}\\n\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract BaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3300;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3320;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3340;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3360;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3380;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3400;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3420;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3440;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3460;\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3480;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3500;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3520;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3540;\\n    uint256 internal constant SORT_IDENTITY = 0x3560;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3580;\\n    uint256 internal constant AUX_IDENTITY = 0x35a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x35c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x35e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3600;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3620;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3640;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3660;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3680;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x36a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x36c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x36e0;\\n\\n    bytes4 internal constant INVALID_VERIFICATION_KEY_SELECTOR = 0x7e5769bf;\\n    bytes4 internal constant POINT_NOT_ON_CURVE_SELECTOR = 0xa3dad654;\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant PAIRING_PREAMBLE_FAILED_SELECTOR = 0x01882d81;\\n    bytes4 internal constant OPENING_COMMITMENT_FAILED_SELECTOR = 0x4e719763;\\n    bytes4 internal constant PAIRING_FAILED_SELECTOR = 0xd71fd263;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n\\n    error INVALID_VERIFICATION_KEY();\\n    error POINT_NOT_ON_CURVE();\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error PAIRING_PREAMBLE_FAILED();\\n    error OPENING_COMMITMENT_FAILED();\\n    error PAIRING_FAILED();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    /**\\n     * @dev We assume that the verification key loaded by this function is constant as we only verify it on deployment\\n     */\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    constructor() { \\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        // We verify that all of the EC points in the verification key lie on the bn128 curve. \\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n\\n            let success := 1\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            } \\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            } \\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            } \\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            } \\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n            }\\n\\n            if iszero(success) {\\n                mstore(0x0, INVALID_VERIFICATION_KEY_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE Q1\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(Q1_X_LOC))\\n            mstore(0x20, mload(Q1_Y_LOC))\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE Q2\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(Q2_X_LOC))\\n            mstore(0x20, mload(Q2_Y_LOC))\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE Q3\\n            \\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(Q3_X_LOC))\\n            mstore(0x20, mload(Q3_Y_LOC))\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE Q4\\n            \\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(Q4_X_LOC))\\n            mstore(0x20, mload(Q4_Y_LOC))\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QM\\n            \\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QM_X_LOC))\\n            mstore(0x20, mload(QM_Y_LOC))\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QC\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QC_X_LOC))\\n            mstore(0x20, mload(QC_Y_LOC))\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QARITH\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QARITH_X_LOC))\\n            mstore(0x20, mload(QARITH_Y_LOC))\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QSORT\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QSORT_X_LOC))\\n            mstore(0x20, mload(QSORT_Y_LOC))\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QELLIPTIC\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QELLIPTIC_X_LOC))\\n            mstore(0x20, mload(QELLIPTIC_Y_LOC))\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE QAUX\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(QAUX_X_LOC))\\n            mstore(0x20, mload(QAUX_Y_LOC))\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE SIGMA1\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(SIGMA1_X_LOC))\\n            mstore(0x20, mload(SIGMA1_Y_LOC))\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE SIGMA2\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(SIGMA2_X_LOC))\\n            mstore(0x20, mload(SIGMA2_Y_LOC))\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE SIGMA3\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(SIGMA3_X_LOC))\\n            mstore(0x20, mload(SIGMA3_Y_LOC))\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE SIGMA4\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(SIGMA4_X_LOC))\\n            mstore(0x20, mload(SIGMA4_Y_LOC))\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE TABLE1\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(TABLE1_X_LOC))\\n            mstore(0x20, mload(TABLE1_Y_LOC))\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE TABLE2\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(TABLE2_X_LOC))\\n            mstore(0x20, mload(TABLE2_Y_LOC))\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE TABLE3\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(TABLE3_X_LOC))\\n            mstore(0x20, mload(TABLE3_Y_LOC))\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE TABLE4\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(TABLE4_X_LOC))\\n            mstore(0x20, mload(TABLE4_Y_LOC))\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE TABLE_TYPE\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(TABLE_TYPE_X_LOC))\\n            mstore(0x20, mload(TABLE_TYPE_Y_LOC))\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE ID1\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(ID1_X_LOC))\\n            mstore(0x20, mload(ID1_Y_LOC))\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE ID2\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(ID2_X_LOC))\\n            mstore(0x20, mload(ID2_Y_LOC))\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE ID3\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(ID3_X_LOC))\\n            mstore(0x20, mload(ID3_Y_LOC))\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // ACCUMULATE ID4\\n\\n            // Verification key fields verified to be on curve at contract deployment\\n            mstore(0x00, mload(ID4_X_LOC))\\n            mstore(0x20, mload(ID4_Y_LOC))\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                if iszero(success) {\\n                    mstore(0x0, OPENING_COMMITMENT_FAILED_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                            revert(0x00, 0x04)\\n                        }\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\\n                            revert(0x00, 0x04)\\n                        }\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, PAIRING_PREAMBLE_FAILED_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                if iszero(and(success, mload(0x00))) {\\n                    mstore(0x0, PAIRING_FAILED_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n            }\\n\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract UltraVerifier is BaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(BaseUltraVerifier) returns (bytes32) {\\n        return UltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(BaseUltraVerifier) {\\n        UltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0xd7f54614b63fc765b2107f67ba7b05d8f4b3b555461cc0d1901f3065b287f132\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162001b0c38038062001b0c833981016040819052620000349162000180565b808281818181806001600160a01b0381166200006a57604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b620000758162000113565b506001600160a01b038083166080528116620000a457604051632d618d8160e21b815260040160405180910390fd5b60805160405163ca5eb5e160e01b81526001600160a01b0383811660048301529091169063ca5eb5e190602401600060405180830381600087803b158015620000ec57600080fd5b505af115801562000101573d6000803e3d6000fd5b505050505050505050505050620001b8565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b03811681146200017b57600080fd5b919050565b600080604083850312156200019457600080fd5b6200019f8362000163565b9150620001af6020840162000163565b90509250929050565b60805161190e620001fe600039600081816102120152818161046a0152818161078401528181610b7a01528181610ce001528181610df20152610ec2015261190e6000f3fe6080604052600436106101445760003560e01c806382413eac116100c0578063ca5eb5e111610074578063ef009f2411610059578063ef009f2414610408578063f2fde38b14610428578063ff7bd03d1461044857600080fd5b8063ca5eb5e1146103c8578063ee82ac5e146103e857600080fd5b806397db6af6116100a557806397db6af614610332578063a48da27a1461037b578063bb0b6a531461039b57600080fd5b806382413eac146102d55780638da5cb5b1461031457600080fd5b80634e859d7411610117578063715018a6116100fc578063715018a61461024c57806377e5d214146102615780637d25a05e1461029957600080fd5b80634e859d74146101d35780635e280f111461020057600080fd5b806313137d651461014957806317442b701461015e57806320b6d85e146101855780633400288b146101b3575b600080fd5b61015c61015736600461122e565b610468565b005b34801561016a57600080fd5b50604080516001815260026020820152015b60405180910390f35b34801561019157600080fd5b506101a56101a03660046112e4565b61055a565b60405190815260200161017c565b3480156101bf57600080fd5b5061015c6101ce366004611336565b610588565b3480156101df57600080fd5b506101f36101ee3660046113d9565b61059e565b60405161017c9190611499565b34801561020c57600080fd5b506102347f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161017c565b34801561025857600080fd5b5061015c610649565b34801561026d57600080fd5b506101a561027c3660046112e4565b600260209081526000928352604080842090915290825290205481565b3480156102a557600080fd5b506102bc6102b4366004611336565b600092915050565b60405167ffffffffffffffff909116815260200161017c565b3480156102e157600080fd5b506103046102f03660046114b0565b6001600160a01b0381163014949350505050565b604051901515815260200161017c565b34801561032057600080fd5b506000546001600160a01b0316610234565b34801561033e57600080fd5b5061030461034d3660046112e4565b67ffffffffffffffff9182166000908152600260209081526040808320939094168252919091522054151590565b61038e610389366004611517565b61065d565b60405161017c9190611571565b3480156103a757600080fd5b506101a56103b63660046115b4565b60016020526000908152604090205481565b3480156103d457600080fd5b5061015c6103e33660046115cf565b610744565b3480156103f457600080fd5b506101a56104033660046115ec565b6107e3565b34801561041457600080fd5b5061015c610423366004611605565b6108e0565b34801561043457600080fd5b5061015c6104433660046115cf565b610958565b34801561045457600080fd5b50610304610463366004611646565b6109af565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633146104d1576040517f91ac5e4f0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b602087018035906104eb906104e6908a6115b4565b6109e5565b14610542576104fd60208801886115b4565b6040517fc26bebcc00000000000000000000000000000000000000000000000000000000815263ffffffff9091166004820152602088013560248201526044016104c8565b61055187878787878787610a3a565b50505050505050565b67ffffffffffffffff8083166000908152600260209081526040808320938516835292905220545b92915050565b610590610ac9565b61059a8282610b0f565b5050565b604080518082019091526000808252602082015260006105bd856107e3565b905060008190036106105760405162461bcd60e51b815260206004820152601360248201527f426c6f636b68617368206e6f7420666f756e640000000000000000000000000060448201526064016104c8565b6040805160208101879052808201839052815180820383018152606090910190915261063e87828787610b64565b979650505050505050565b610651610ac9565b61065b6000610c45565b565b610665611170565b6000610670856107e3565b905060008190036106c35760405162461bcd60e51b815260206004820152601360248201527f426c6f636b68617368206e6f7420666f756e640000000000000000000000000060448201526064016104c8565b604080516020810187905290810182905246606082015260009060800160408051601f198184030181526020601f8801819004810284018101909252868352925061063e918991849190899089908190840183828082843760009201829052506040805180820190915234815260208101919091529250339150610cad9050565b61074c610ac9565b6040517fca5eb5e10000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063ca5eb5e190602401600060405180830381600087803b1580156107c857600080fd5b505af11580156107dc573d6000803e3d6000fd5b5050505050565b600081431161085a5760405162461bcd60e51b815260206004820152602260248201527f426c6f636b206e756d6265722073686f756c6420626520696e2074686520706160448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016104c8565b6101006108678343611662565b11156108db5760405162461bcd60e51b815260206004820152602360248201527f426c6f636b206e756d62657220697320746f6f2066617220696e20746865207060448201527f617374000000000000000000000000000000000000000000000000000000000060648201526084016104c8565b504090565b6108e8610ac9565b67ffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902085905581519283528201929092529081018290527ffe35adc49ef5e4a7eda5c9cab9338a872c9c0ae436c53d4cb8bb4900b2d48da49060600160405180910390a1505050565b610960610ac9565b6001600160a01b0381166109a3576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016104c8565b6109ac81610c45565b50565b60006020820180359060019083906109c790866115b4565b63ffffffff1681526020810191909152604001600020541492915050565b63ffffffff811660009081526001602052604081205480610582576040517ff6ff4fb700000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024016104c8565b60008080610a4a8789018961169c565b67ffffffffffffffff818116600081815260026020908152604080832094881680845294825291829020869055815192835282019290925290810183905292955090935091507ffe35adc49ef5e4a7eda5c9cab9338a872c9c0ae436c53d4cb8bb4900b2d48da49060600160405180910390a150505050505050505050565b6000546001600160a01b0316331461065b576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016104c8565b63ffffffff8216600081815260016020908152604091829020849055815192835282018390527f238399d427b947898edb290f5ff0f9109849b1c3ba196a42e35f00c50a54b98b910160405180910390a15050565b60408051808201909152600080825260208201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ddc28c586040518060a001604052808863ffffffff168152602001610bc7896109e5565b8152602001878152602001868152602001851515815250306040518363ffffffff1660e01b8152600401610bfc929190611718565b6040805180830381865afa158015610c18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c3c91906117fe565b95945050505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610cb5611170565b6000610cc48460000151610dad565b602085015190915015610cde57610cde8460200151610dee565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632637a450826040518060a001604052808b63ffffffff168152602001610d2e8c6109e5565b81526020018a815260200189815260200160008960200151111515815250866040518463ffffffff1660e01b8152600401610d6a929190611718565b60806040518083038185885af1158015610d88573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061063e919061181a565b6000813414610dea576040517f9f7041200000000000000000000000000000000000000000000000000000000081523460048201526024016104c8565b5090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e4fe1d946040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e729190611882565b90506001600160a01b038116610eb4576040517f5373352a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040805133602482018190527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03818116604485015260648085018890528551808603909101815260849094019094526020830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd0000000000000000000000000000000000000000000000000000000017905261059a938516928690610f67908590610f6d565b50505050565b6000610f826001600160a01b03841683610fee565b90508051600014158015610fa7575080806020019051810190610fa5919061189f565b155b15610fe9576040517f5274afe70000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016104c8565b505050565b6060610ffc83836000611003565b9392505050565b606081471015611041576040517fcd7860590000000000000000000000000000000000000000000000000000000081523060048201526024016104c8565b600080856001600160a01b0316848660405161105d91906118bc565b60006040518083038185875af1925050503d806000811461109a576040519150601f19603f3d011682016040523d82523d6000602084013e61109f565b606091505b50915091506110af8683836110b9565b9695505050505050565b6060826110ce576110c98261112e565b610ffc565b81511580156110e557506001600160a01b0384163b155b15611127576040517f9996b3150000000000000000000000000000000000000000000000000000000081526001600160a01b03851660048201526024016104c8565b5080610ffc565b80511561113e5780518082602001fd5b6040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806060016040528060008019168152602001600067ffffffffffffffff1681526020016111b3604051806040016040528060008152602001600081525090565b905290565b6000606082840312156111ca57600080fd5b50919050565b60008083601f8401126111e257600080fd5b50813567ffffffffffffffff8111156111fa57600080fd5b60208301915083602082850101111561121257600080fd5b9250929050565b6001600160a01b03811681146109ac57600080fd5b600080600080600080600060e0888a03121561124957600080fd5b61125389896111b8565b965060608801359550608088013567ffffffffffffffff8082111561127757600080fd5b6112838b838c016111d0565b909750955060a08a0135915061129882611219565b90935060c089013590808211156112ae57600080fd5b506112bb8a828b016111d0565b989b979a50959850939692959293505050565b67ffffffffffffffff811681146109ac57600080fd5b600080604083850312156112f757600080fd5b8235611302816112ce565b91506020830135611312816112ce565b809150509250929050565b803563ffffffff8116811461133157600080fd5b919050565b6000806040838503121561134957600080fd5b6113528361131d565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156113b8576113b8611360565b604052919050565b80151581146109ac57600080fd5b8035611331816113c0565b600080600080608085870312156113ef57600080fd5b6113f88561131d565b93506020808601359350604086013567ffffffffffffffff8082111561141d57600080fd5b818801915088601f83011261143157600080fd5b81358181111561144357611443611360565b61145584601f19601f8401160161138f565b9150808252898482850101111561146b57600080fd5b808484018584013760008482840101525080945050505061148e606086016113ce565b905092959194509250565b815181526020808301519082015260408101610582565b60008060008060a085870312156114c657600080fd5b6114d086866111b8565b9350606085013567ffffffffffffffff8111156114ec57600080fd5b6114f8878288016111d0565b909450925050608085013561150c81611219565b939692955090935050565b6000806000806060858703121561152d57600080fd5b6115368561131d565b935060208501359250604085013567ffffffffffffffff81111561155957600080fd5b611565878288016111d0565b95989497509550505050565b60006080820190508251825267ffffffffffffffff602084015116602083015260408301516115ad604084018280518252602090810151910152565b5092915050565b6000602082840312156115c657600080fd5b610ffc8261131d565b6000602082840312156115e157600080fd5b8135610ffc81611219565b6000602082840312156115fe57600080fd5b5035919050565b60008060006060848603121561161a57600080fd5b8335611625816112ce565b92506020840135611635816112ce565b929592945050506040919091013590565b60006060828403121561165857600080fd5b610ffc83836111b8565b81810381811115610582577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000806000606084860312156116b157600080fd5b505081359360208301359350604090920135919050565b60005b838110156116e35781810151838201526020016116cb565b50506000910152565b600081518084526117048160208601602086016116c8565b601f01601f19169290920160200192915050565b6040815263ffffffff8351166040820152602083015160608201526000604084015160a0608084015261174e60e08401826116ec565b905060608501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08483030160a085015261178982826116ec565b60809690960151151560c08501525050506001600160a01b039190911660209091015290565b6000604082840312156117c157600080fd5b6040516040810181811067ffffffffffffffff821117156117e4576117e4611360565b604052825181526020928301519281019290925250919050565b60006040828403121561181057600080fd5b610ffc83836117af565b60006080828403121561182c57600080fd5b6040516060810181811067ffffffffffffffff8211171561184f5761184f611360565b604052825181526020830151611864816112ce565b602082015261187684604085016117af565b60408201529392505050565b60006020828403121561189457600080fd5b8151610ffc81611219565b6000602082840312156118b157600080fd5b8151610ffc816113c0565b600082516118ce8184602087016116c8565b919091019291505056fea26469706673582212204c856209f8e10886ce96750dca3ee987e62b6b5a72289cb167c0deb58381424064736f6c63430008180033",
  "deployedBytecode": "0x6080604052600436106101445760003560e01c806382413eac116100c0578063ca5eb5e111610074578063ef009f2411610059578063ef009f2414610408578063f2fde38b14610428578063ff7bd03d1461044857600080fd5b8063ca5eb5e1146103c8578063ee82ac5e146103e857600080fd5b806397db6af6116100a557806397db6af614610332578063a48da27a1461037b578063bb0b6a531461039b57600080fd5b806382413eac146102d55780638da5cb5b1461031457600080fd5b80634e859d7411610117578063715018a6116100fc578063715018a61461024c57806377e5d214146102615780637d25a05e1461029957600080fd5b80634e859d74146101d35780635e280f111461020057600080fd5b806313137d651461014957806317442b701461015e57806320b6d85e146101855780633400288b146101b3575b600080fd5b61015c61015736600461122e565b610468565b005b34801561016a57600080fd5b50604080516001815260026020820152015b60405180910390f35b34801561019157600080fd5b506101a56101a03660046112e4565b61055a565b60405190815260200161017c565b3480156101bf57600080fd5b5061015c6101ce366004611336565b610588565b3480156101df57600080fd5b506101f36101ee3660046113d9565b61059e565b60405161017c9190611499565b34801561020c57600080fd5b506102347f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161017c565b34801561025857600080fd5b5061015c610649565b34801561026d57600080fd5b506101a561027c3660046112e4565b600260209081526000928352604080842090915290825290205481565b3480156102a557600080fd5b506102bc6102b4366004611336565b600092915050565b60405167ffffffffffffffff909116815260200161017c565b3480156102e157600080fd5b506103046102f03660046114b0565b6001600160a01b0381163014949350505050565b604051901515815260200161017c565b34801561032057600080fd5b506000546001600160a01b0316610234565b34801561033e57600080fd5b5061030461034d3660046112e4565b67ffffffffffffffff9182166000908152600260209081526040808320939094168252919091522054151590565b61038e610389366004611517565b61065d565b60405161017c9190611571565b3480156103a757600080fd5b506101a56103b63660046115b4565b60016020526000908152604090205481565b3480156103d457600080fd5b5061015c6103e33660046115cf565b610744565b3480156103f457600080fd5b506101a56104033660046115ec565b6107e3565b34801561041457600080fd5b5061015c610423366004611605565b6108e0565b34801561043457600080fd5b5061015c6104433660046115cf565b610958565b34801561045457600080fd5b50610304610463366004611646565b6109af565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633146104d1576040517f91ac5e4f0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b602087018035906104eb906104e6908a6115b4565b6109e5565b14610542576104fd60208801886115b4565b6040517fc26bebcc00000000000000000000000000000000000000000000000000000000815263ffffffff9091166004820152602088013560248201526044016104c8565b61055187878787878787610a3a565b50505050505050565b67ffffffffffffffff8083166000908152600260209081526040808320938516835292905220545b92915050565b610590610ac9565b61059a8282610b0f565b5050565b604080518082019091526000808252602082015260006105bd856107e3565b905060008190036106105760405162461bcd60e51b815260206004820152601360248201527f426c6f636b68617368206e6f7420666f756e640000000000000000000000000060448201526064016104c8565b6040805160208101879052808201839052815180820383018152606090910190915261063e87828787610b64565b979650505050505050565b610651610ac9565b61065b6000610c45565b565b610665611170565b6000610670856107e3565b905060008190036106c35760405162461bcd60e51b815260206004820152601360248201527f426c6f636b68617368206e6f7420666f756e640000000000000000000000000060448201526064016104c8565b604080516020810187905290810182905246606082015260009060800160408051601f198184030181526020601f8801819004810284018101909252868352925061063e918991849190899089908190840183828082843760009201829052506040805180820190915234815260208101919091529250339150610cad9050565b61074c610ac9565b6040517fca5eb5e10000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063ca5eb5e190602401600060405180830381600087803b1580156107c857600080fd5b505af11580156107dc573d6000803e3d6000fd5b5050505050565b600081431161085a5760405162461bcd60e51b815260206004820152602260248201527f426c6f636b206e756d6265722073686f756c6420626520696e2074686520706160448201527f737400000000000000000000000000000000000000000000000000000000000060648201526084016104c8565b6101006108678343611662565b11156108db5760405162461bcd60e51b815260206004820152602360248201527f426c6f636b206e756d62657220697320746f6f2066617220696e20746865207060448201527f617374000000000000000000000000000000000000000000000000000000000060648201526084016104c8565b504090565b6108e8610ac9565b67ffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902085905581519283528201929092529081018290527ffe35adc49ef5e4a7eda5c9cab9338a872c9c0ae436c53d4cb8bb4900b2d48da49060600160405180910390a1505050565b610960610ac9565b6001600160a01b0381166109a3576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016104c8565b6109ac81610c45565b50565b60006020820180359060019083906109c790866115b4565b63ffffffff1681526020810191909152604001600020541492915050565b63ffffffff811660009081526001602052604081205480610582576040517ff6ff4fb700000000000000000000000000000000000000000000000000000000815263ffffffff841660048201526024016104c8565b60008080610a4a8789018961169c565b67ffffffffffffffff818116600081815260026020908152604080832094881680845294825291829020869055815192835282019290925290810183905292955090935091507ffe35adc49ef5e4a7eda5c9cab9338a872c9c0ae436c53d4cb8bb4900b2d48da49060600160405180910390a150505050505050505050565b6000546001600160a01b0316331461065b576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016104c8565b63ffffffff8216600081815260016020908152604091829020849055815192835282018390527f238399d427b947898edb290f5ff0f9109849b1c3ba196a42e35f00c50a54b98b910160405180910390a15050565b60408051808201909152600080825260208201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ddc28c586040518060a001604052808863ffffffff168152602001610bc7896109e5565b8152602001878152602001868152602001851515815250306040518363ffffffff1660e01b8152600401610bfc929190611718565b6040805180830381865afa158015610c18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c3c91906117fe565b95945050505050565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610cb5611170565b6000610cc48460000151610dad565b602085015190915015610cde57610cde8460200151610dee565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632637a450826040518060a001604052808b63ffffffff168152602001610d2e8c6109e5565b81526020018a815260200189815260200160008960200151111515815250866040518463ffffffff1660e01b8152600401610d6a929190611718565b60806040518083038185885af1158015610d88573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061063e919061181a565b6000813414610dea576040517f9f7041200000000000000000000000000000000000000000000000000000000081523460048201526024016104c8565b5090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e4fe1d946040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e729190611882565b90506001600160a01b038116610eb4576040517f5373352a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040805133602482018190527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03818116604485015260648085018890528551808603909101815260849094019094526020830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd0000000000000000000000000000000000000000000000000000000017905261059a938516928690610f67908590610f6d565b50505050565b6000610f826001600160a01b03841683610fee565b90508051600014158015610fa7575080806020019051810190610fa5919061189f565b155b15610fe9576040517f5274afe70000000000000000000000000000000000000000000000000000000081526001600160a01b03841660048201526024016104c8565b505050565b6060610ffc83836000611003565b9392505050565b606081471015611041576040517fcd7860590000000000000000000000000000000000000000000000000000000081523060048201526024016104c8565b600080856001600160a01b0316848660405161105d91906118bc565b60006040518083038185875af1925050503d806000811461109a576040519150601f19603f3d011682016040523d82523d6000602084013e61109f565b606091505b50915091506110af8683836110b9565b9695505050505050565b6060826110ce576110c98261112e565b610ffc565b81511580156110e557506001600160a01b0384163b155b15611127576040517f9996b3150000000000000000000000000000000000000000000000000000000081526001600160a01b03851660048201526024016104c8565b5080610ffc565b80511561113e5780518082602001fd5b6040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806060016040528060008019168152602001600067ffffffffffffffff1681526020016111b3604051806040016040528060008152602001600081525090565b905290565b6000606082840312156111ca57600080fd5b50919050565b60008083601f8401126111e257600080fd5b50813567ffffffffffffffff8111156111fa57600080fd5b60208301915083602082850101111561121257600080fd5b9250929050565b6001600160a01b03811681146109ac57600080fd5b600080600080600080600060e0888a03121561124957600080fd5b61125389896111b8565b965060608801359550608088013567ffffffffffffffff8082111561127757600080fd5b6112838b838c016111d0565b909750955060a08a0135915061129882611219565b90935060c089013590808211156112ae57600080fd5b506112bb8a828b016111d0565b989b979a50959850939692959293505050565b67ffffffffffffffff811681146109ac57600080fd5b600080604083850312156112f757600080fd5b8235611302816112ce565b91506020830135611312816112ce565b809150509250929050565b803563ffffffff8116811461133157600080fd5b919050565b6000806040838503121561134957600080fd5b6113528361131d565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156113b8576113b8611360565b604052919050565b80151581146109ac57600080fd5b8035611331816113c0565b600080600080608085870312156113ef57600080fd5b6113f88561131d565b93506020808601359350604086013567ffffffffffffffff8082111561141d57600080fd5b818801915088601f83011261143157600080fd5b81358181111561144357611443611360565b61145584601f19601f8401160161138f565b9150808252898482850101111561146b57600080fd5b808484018584013760008482840101525080945050505061148e606086016113ce565b905092959194509250565b815181526020808301519082015260408101610582565b60008060008060a085870312156114c657600080fd5b6114d086866111b8565b9350606085013567ffffffffffffffff8111156114ec57600080fd5b6114f8878288016111d0565b909450925050608085013561150c81611219565b939692955090935050565b6000806000806060858703121561152d57600080fd5b6115368561131d565b935060208501359250604085013567ffffffffffffffff81111561155957600080fd5b611565878288016111d0565b95989497509550505050565b60006080820190508251825267ffffffffffffffff602084015116602083015260408301516115ad604084018280518252602090810151910152565b5092915050565b6000602082840312156115c657600080fd5b610ffc8261131d565b6000602082840312156115e157600080fd5b8135610ffc81611219565b6000602082840312156115fe57600080fd5b5035919050565b60008060006060848603121561161a57600080fd5b8335611625816112ce565b92506020840135611635816112ce565b929592945050506040919091013590565b60006060828403121561165857600080fd5b610ffc83836111b8565b81810381811115610582577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000806000606084860312156116b157600080fd5b505081359360208301359350604090920135919050565b60005b838110156116e35781810151838201526020016116cb565b50506000910152565b600081518084526117048160208601602086016116c8565b601f01601f19169290920160200192915050565b6040815263ffffffff8351166040820152602083015160608201526000604084015160a0608084015261174e60e08401826116ec565b905060608501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08483030160a085015261178982826116ec565b60809690960151151560c08501525050506001600160a01b039190911660209091015290565b6000604082840312156117c157600080fd5b6040516040810181811067ffffffffffffffff821117156117e4576117e4611360565b604052825181526020928301519281019290925250919050565b60006040828403121561181057600080fd5b610ffc83836117af565b60006080828403121561182c57600080fd5b6040516060810181811067ffffffffffffffff8211171561184f5761184f611360565b604052825181526020830151611864816112ce565b602082015261187684604085016117af565b60408201529392505050565b60006020828403121561189457600080fd5b8151610ffc81611219565b6000602082840312156118b157600080fd5b8151610ffc816113c0565b600082516118ce8184602087016116c8565b919091019291505056fea26469706673582212204c856209f8e10886ce96750dca3ee987e62b6b5a72289cb167c0deb58381424064736f6c63430008180033",
  "devdoc": {
    "errors": {
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "AddressInsufficientBalance(address)": [
        {
          "details": "The ETH balance of the account is not enough to perform the operation."
        }
      ],
      "FailedInnerCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "allowInitializePath((uint32,bytes32,uint64))": {
        "details": "This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.This defaults to assuming if a peer has been set, its initialized. Can be overridden by the OApp if there is other logic to determine this.",
        "params": {
          "origin": "The origin information containing the source endpoint and sender address."
        },
        "returns": {
          "_0": "Whether the path has been initialized."
        }
      },
      "isComposeMsgSender((uint32,bytes32,uint64),bytes,address)": {
        "details": "_origin The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message._message The lzReceive payload.Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.The default sender IS the OAppReceiver implementer.",
        "params": {
          "_sender": "The sender address."
        },
        "returns": {
          "_0": "isSender Is a valid sender."
        }
      },
      "lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)": {
        "details": "Entry point for receiving messages or packets from the endpoint.Entry point for receiving msg/packet from the LayerZero endpoint.",
        "params": {
          "_executor": "The address of the executor for the received message.",
          "_extraData": "Additional arbitrary data provided by the corresponding executor.",
          "_guid": "The unique identifier for the received LayerZero message.",
          "_message": "The payload of the received message.",
          "_origin": "The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message."
        }
      },
      "nextNonce(uint32,bytes32)": {
        "details": "_srcEid The source endpoint ID._sender The sender address.The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.Is required by the off-chain executor to determine the OApp expects msg execution is ordered.This is also enforced by the OApp.By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.",
        "returns": {
          "nonce": "The next nonce."
        }
      },
      "oAppVersion()": {
        "returns": {
          "receiverVersion": "The version of the OAppReceiver.sol implementation.",
          "senderVersion": "The version of the OAppSender.sol implementation."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "setDelegate(address)": {
        "details": "Only the owner/admin of the OApp can call this function.Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.",
        "params": {
          "_delegate": "The address of the delegate to be set."
        }
      },
      "setPeer(uint32,bytes32)": {
        "details": "Only the owner/admin of the OApp can call this function.Indicates that the peer is trusted to send LayerZero messages to this OApp.Set this to bytes32(0) to remove the peer address.Peer is a bytes32 to accommodate non-evm chains.",
        "params": {
          "_eid": "The endpoint ID.",
          "_peer": "The address of the peer to be associated with the corresponding endpoint."
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "allowInitializePath((uint32,bytes32,uint64))": {
        "notice": "Checks if the path initialization is allowed based on the provided origin."
      },
      "endpoint()": {
        "notice": "Retrieves the LayerZero endpoint associated with the OApp."
      },
      "isComposeMsgSender((uint32,bytes32,uint64),bytes,address)": {
        "notice": "Indicates whether an address is an approved composeMsg sender to the Endpoint."
      },
      "nextNonce(uint32,bytes32)": {
        "notice": "Retrieves the next nonce for a given source endpoint and sender address."
      },
      "oAppVersion()": {
        "notice": "Retrieves the OApp version information."
      },
      "peers(uint32)": {
        "notice": "Retrieves the peer (OApp) associated with a corresponding endpoint."
      },
      "setDelegate(address)": {
        "notice": "Sets the delegate address for the OApp."
      },
      "setPeer(uint32,bytes32)": {
        "notice": "Sets the peer address (OApp instance) for a corresponding endpoint."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1327,
        "contract": "contracts/Lisan.sol:Lisan",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 64,
        "contract": "contracts/Lisan.sol:Lisan",
        "label": "peers",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 2289,
        "contract": "contracts/Lisan.sol:Lisan",
        "label": "visions",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint64,t_mapping(t_uint64,t_bytes32))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint64,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint64,t_mapping(t_uint64,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(uint64 => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint64,t_bytes32)"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}